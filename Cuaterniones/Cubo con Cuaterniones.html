<!DOCTYPE HTML>
<html>
<head>
  <style>
    html, body {
      width:  100%;
      height: 100%;
      margin: 0px;
      border: 0;
      overflow: hidden;
      display: block;
    }
  </style>    
  <title>Cubo Color Interacción en WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
  <canvas id="webglcanvas" style="border: none;" width="500" height="500"></canvas>

  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    out vec4 vColores;
    void main() {
      vColores = aColores;  
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec4 vColores;
    out vec4 color;
    void main() {
        color = vColores;
    }
  </script>

  <script>
    "use strict";

    /***************************************************************************/
    /* CLASE CUATERNIÓN - Implementación Simple                               */
    /***************************************************************************/
    class Quat {
      constructor(x = 0, y = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }

      // Crear desde ángulo (radianes) y eje normalizado
      static fromAxisAngle(axisX, axisY, axisZ, angleRad) {
        const halfAngle = angleRad * 0.5;
        const s = Math.sin(halfAngle);
        return new Quat(
          axisX * s,
          axisY * s,
          axisZ * s,
          Math.cos(halfAngle)
        );
      }

      // Multiplicar cuaterniones: q1 * q2
      multiply(q) {
        return new Quat(
          this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,
          this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,
          this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w,
          this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z
        );
      }

      // Normalizar
      normalize() {
        const len = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        if (len > 0.00001) {
          this.x /= len;
          this.y /= len;
          this.z /= len;
          this.w /= len;
        }
        return this;
      }

      // Convertir a matriz 4x4 (column-major para WebGL)
      toMatrix() {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;

        return [
          1 - (yy + zz), xy + wz,       xz - wy,       0,
          xy - wz,       1 - (xx + zz), yz + wx,       0,
          xz + wy,       yz - wx,       1 - (xx + yy), 0,
          0,             0,             0,             1
        ];
      }
    }

    /***************************************************************************/
    /* Transformaciones mediante matrices                                      */
    /***************************************************************************/

    function identidad(r) {
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function escalacion(matriz, sx, sy, sz) { 
      let r = new Array(16);
      r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
      r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
      r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2/(der - izq); r[4] = 0; r[ 8] = 0; r[12] = -(der + izq)/(der - izq);
      r[1] = 0; r[5] = 2/(arr - abj); r[ 9] = 0; r[13] = -(arr + abj)/(arr - abj);
      r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++){
        for (j = 0; j < 4; j++){
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
          r[i + j * 4] = s;
        }
      }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }

    /***************************************************************************/
    /* Variables globales                                                      */
    /***************************************************************************/
    let gl, canvas;
    let programaID;
    let cuboVAO;

    // CUATERNIÓN en lugar de rotX, rotY
    let quaternion = new Quat(); // Orientación actual del cubo

    let antX, antY;
    let boton_izq_presionado = false;

    let uMatrizProyeccion, uMatrizVista, uMatrizModelo;
    let MatrizProyeccion = new Array(16);
    let MatrizVista = new Array(16);
    let MatrizModelo = new Array(16);

    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/

    function mouseDown(event) {
      let posx = (event.x !== undefined) ? event.x : event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      let posy = (event.y !== undefined) ? event.y : event.clientY + document.body.scrollTop + document.documentElement.scrollTop;

      posx -= canvas.offsetLeft;
      posy -= canvas.offsetTop;

      antX = posx;
      antY = posy;
      boton_izq_presionado = true;

      return false;
    }

    function mouseUp(e){
      boton_izq_presionado = false;
    }

    function mouseMove(event) {
      if (!boton_izq_presionado)
        return false;

      let posx = (event.x !== undefined) ? event.x : event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      let posy = (event.y !== undefined) ? event.y : event.clientY + document.body.scrollTop + document.documentElement.scrollTop;

      posx -= canvas.offsetLeft;
      posy -= canvas.offsetTop;

      let dx = posx - antX;
      let dy = posy - antY;

      // CLAVE: Eje perpendicular al movimiento del mouse
      // dx → rotar alrededor de Y (eje vertical)
      // dy → rotar alrededor de X (eje horizontal)
      
      let axisY = 1; // Eje Y (vertical)
      let axisX = 1; // Eje X (horizontal)
      
      // Ángulos proporcionales al movimiento (en radianes)
      let angleY = dx * 0.01; // Rotación horizontal
      let angleX = dy * 0.01; // Rotación vertical

      // Crear cuaterniones para cada rotación
      let quatY = Quat.fromAxisAngle(0, axisY, 0, angleY);
      let quatX = Quat.fromAxisAngle(axisX, 0, 0, angleX);

      // Componer: primero Y, luego X
      let deltaQuat = quatY.multiply(quatX);

      // MULTIPLICAR con el cuaternión actual (orden importa)
      quaternion = deltaQuat.multiply(quaternion).normalize();

      antX = posx;
      antY = posy;
    }

    /***************************************************************************/
    /* Renderizado                                                             */
    /***************************************************************************/

    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Construir matriz del modelo
      identidad(MatrizModelo);
      
      // Aplicar rotación del cuaternión
      let rotMatrix = quaternion.toMatrix();
      multiplica(MatrizModelo, MatrizModelo, rotMatrix);
      
      // Aplicar escala
      escalacion(MatrizModelo, 2, 2, 2);
      
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      gl.bindVertexArray(cuboVAO);
      gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
      gl.bindVertexArray(null);

      requestAnimationFrame(dibuja);
    }

    /***************************************************************************/
    /* Función Principal                                                       */
    /***************************************************************************/

    function main() {
      canvas = document.getElementById("webglcanvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      gl = canvas.getContext("webgl2");
      if (!gl) {
         document.write("WebGL 2.0 no está disponible en tu navegador");
         return;
      }

      canvas.addEventListener("mousedown", mouseDown, false);
      canvas.addEventListener("mouseup", mouseUp, false);
      canvas.addEventListener("mouseout", mouseUp, false);
      canvas.addEventListener("mousemove", mouseMove, false);

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);

      let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);

      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice); 
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);

      gl.useProgram(programaID);

      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

      /***************************************************************************/
      /* Geometría del cubo                                                      */
      /***************************************************************************/

      let vertices = [
          -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1,
          -1,  1, -1,  1,  1, -1,  1, -1, -1, -1, -1, -1,
          -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1,
           1, -1,  1,  1, -1, -1,  1,  1, -1,  1,  1,  1,
          -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,
          -1,  1,  1,  1,  1,  1,  1,  1, -1, -1,  1, -1
      ];

      let colores = [
          1, 0, 1, 1,  1, 0, 1, 1,  1, 0, 1, 1,  1, 0, 1, 1,
          1, 1, 0, 1,  1, 1, 0, 1,  1, 1, 0, 1,  1, 1, 0, 1,
          0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,
          1, 0, 0, 1,  1, 0, 0, 1,  1, 0, 0, 1,  1, 0, 0, 1,
          0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1,
          0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1
      ];

      let indices = [ 
         0,  1,  2,  0,  2,  3,
         4,  5,  6,  4,  6,  7,
         8,  9, 10,  8, 10, 11,
        12, 13, 14, 12, 14, 15,
        16, 17, 18, 16, 18, 19,
        20, 21, 22, 20, 22, 23
      ];

      cuboVAO = gl.createVertexArray();
      gl.bindVertexArray(cuboVAO);

      let codigoVertices = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      let codigoColores = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

      let codigoDeIndices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      /***************************************************************************/
      /* Configuración final                                                     */
      /***************************************************************************/

      ortho(MatrizProyeccion, -5 * gl.canvas.width/gl.canvas.height, 5 * gl.canvas.width/gl.canvas.height, -5, 5, -5, 5);
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

      identidad(MatrizVista);
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      
      dibuja();
    }

    window.onload = main;

  </script>
</body>
</html>