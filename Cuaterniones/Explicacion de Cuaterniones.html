<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cuaterniones vs √Ångulos de Euler - by: David S.C.</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 40px 20px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      margin-bottom: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    h1 {
      font-size: 3em;
      color: #667eea;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }

    .subtitle {
      font-size: 1.3em;
      color: #666;
    }

    .demo-section {
      background: white;
      border-radius: 20px;
      padding: 40px;
      margin-bottom: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    .demo-section h2 {
      color: #667eea;
      font-size: 2em;
      margin-bottom: 20px;
      border-bottom: 3px solid #667eea;
      padding-bottom: 10px;
    }

    .comparison-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin: 30px 0;
    }

    .canvas-container {
      position: relative;
      background: #f5f5f5;
      border-radius: 15px;
      padding: 20px;
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .canvas-container h3 {
      text-align: center;
      margin-bottom: 15px;
      color: #333;
      font-size: 1.3em;
    }

    canvas {
      display: block;
      margin: 0 auto;
      border-radius: 10px;
      background: #000;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    .status {
      text-align: center;
      margin-top: 15px;
      padding: 15px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .info-box {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 25px;
      border-radius: 15px;
      margin: 20px 0;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
    }

    .info-box h3 {
      margin-bottom: 15px;
      font-size: 1.5em;
    }

    .code-block {
      background: #2d3748;
      color: #68d391;
      padding: 20px;
      border-radius: 10px;
      font-family: 'Courier New', monospace;
      overflow-x: auto;
      margin: 15px 0;
      font-size: 0.9em;
      line-height: 1.5;
    }

    .code-comment {
      color: #a0aec0;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .comparison-table th,
    .comparison-table td {
      padding: 15px;
      text-align: left;
      border-bottom: 1px solid #e2e8f0;
    }

    .comparison-table th {
      background: #667eea;
      color: white;
      font-weight: bold;
    }

    .comparison-table tr:nth-child(even) {
      background: #f7fafc;
    }

    .pros {
      color: #48bb78;
      font-weight: bold;
    }

    .cons {
      color: #f56565;
      font-weight: bold;
    }

    .interactive-note {
      background: #fef5e7;
      border-left: 5px solid #f39c12;
      padding: 20px;
      margin: 20px 0;
      border-radius: 5px;
    }

    .interactive-note strong {
      color: #e67e22;
    }

    .math-formula {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin: 15px 0;
      text-align: center;
      font-size: 1.2em;
      border: 2px solid #667eea;
    }

    .step-by-step {
      counter-reset: step;
      margin: 20px 0;
    }

    .step {
      counter-increment: step;
      background: white;
      padding: 20px;
      margin: 15px 0;
      border-radius: 10px;
      border-left: 5px solid #667eea;
      position: relative;
      padding-left: 80px;
    }

    .step::before {
      content: counter(step);
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: #667eea;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.5em;
    }

    .highlight {
      background: linear-gradient(120deg, #fef5e7 0%, #fef5e7 100%);
      background-repeat: no-repeat;
      background-size: 100% 40%;
      background-position: 0 80%;
      padding: 2px 5px;
    }

    @media (max-width: 768px) {
      .comparison-grid {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 2em;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéÆ Cuaterniones vs √Ångulos de Euler</h1>
      <p class="subtitle">Tutorial por David S. Ch.</p>
    </header>

    <!-- SECCI√ìN 1: DEMO INTERACTIVA -->
    <div class="demo-section">
      <h2>üéØ Prueba la Diferencia T√∫ Mismo</h2>
      
      <div class="interactive-note">
        <strong>üëÜ Instrucciones:</strong> Arrastra cada cubo con el mouse. Intenta rotarlo completamente hasta ponerlo "de lado" (90¬∞) y sigue rot√°ndolo. ¬°Observa qu√© sucede!
      </div>

      <div class="comparison-grid">
        <div class="canvas-container">
          <h3>‚ùå √Ångulos de Euler (Problem√°tico)</h3>
          <canvas id="canvasEuler" width="400" height="400"></canvas>
          <div class="status" id="statusEuler">
            <div>Rotaci√≥n X: <span id="eulerX">0¬∞</span></div>
            <div>Rotaci√≥n Y: <span id="eulerY">0¬∞</span></div>
          </div>
        </div>

        <div class="canvas-container">
          <h3>‚úÖ Cuaterniones (Correcto)</h3>
          <canvas id="canvasQuat" width="400" height="400"></canvas>
          <div class="status" id="statusQuat">
            <div>Quat: (<span id="quatValues">0, 0, 0, 1</span>)</div>
          </div>
        </div>
      </div>
    </div>

    <!-- SECCI√ìN 2: ¬øQU√â SON? -->
    <div class="demo-section">
      <h2>üìö ¬øQu√© son los Cuaterniones?</h2>
      
      <p style="font-size: 1.1em; margin-bottom: 20px;">
        Los cuaterniones son una extensi√≥n de los n√∫meros complejos que se usan para representar <span class="highlight">rotaciones 3D sin los problemas de los √°ngulos de Euler</span>.
      </p>

      <div class="math-formula">
        <strong>q = w + xi + yj + zk</strong>
        <div style="font-size: 0.8em; color: #666; margin-top: 10px;">
          donde i¬≤ = j¬≤ = k¬≤ = ijk = -1
        </div>
      </div>

      <div class="info-box">
        <h3>üî¢ Componentes del Cuaterni√≥n</h3>
        <ul style="list-style: none; padding-left: 0;">
          <li style="margin: 10px 0;">‚ú¶ <strong>x, y, z</strong>: Parte vectorial (relacionada con el <strong>eje de rotaci√≥n</strong>)</li>
          <li style="margin: 10px 0;">‚ú¶ <strong>w</strong>: Parte escalar (relacionada con el <strong>√°ngulo de rotaci√≥n</strong>)</li>
        </ul>
      </div>

      <div class="step-by-step">
        <div class="step">
          <h4>Crear un Cuaterni√≥n de Rotaci√≥n</h4>
          <p>Para rotar <strong>Œ∏ radianes</strong> alrededor del eje <strong>(ax, ay, az)</strong> normalizado:</p>
          <div class="code-block">
            halfAngle = Œ∏ / 2<br>
            s = sin(halfAngle)<br><br>

            q.x = ax √ó s<br>
            q.y = ay √ó s<br>
            q.z = az √ó s<br>
            q.w = cos(halfAngle)
          </div>
        </div>

        <div class="step">
          <h4>Multiplicar Cuaterniones</h4>
          <p>Para <strong>componer rotaciones</strong>, multiplicamos cuaterniones (como multiplicar matrices):</p>
          <div class="code-block">
            <span class="code-comment">// Primero aplica q2, luego q1</span><br>
            q_final = q1.multiply(q2)
          </div>
        </div>

        <div class="step">
          <h4>Convertir a Matriz</h4>
          <p>Para usar en WebGL, convertimos el cuaterni√≥n a una matriz 4√ó4:</p>
          <div class="code-block">
            matrix = quaternion.toMatrix()
          </div>
        </div>
      </div>
    </div>

    <!-- SECCI√ìN 3: COMPARACI√ìN DE C√ìDIGO -->
    <div class="demo-section">
      <h2>üíª Comparaci√≥n de C√≥digo Paso a Paso</h2>

      <div style="background: #f0f4ff; padding: 30px; border-radius: 15px; margin-bottom: 30px;">
        <h3 style="color: #667eea; text-align: center; margin-bottom: 20px;">üì¶ PASO 1: Variables de Estado</h3>
        
        <div class="comparison-grid">
          <div>
            <div style="background: #fff5f5; padding: 20px; border-radius: 10px; border-left: 5px solid #f56565;">
              <h4 style="color: #f56565; margin-bottom: 15px;">‚ùå √Ångulos de Euler</h4>
              <div class="code-block">
                <span class="code-comment">// Guardamos 2 √°ngulos separados</span><br>
                let rotX = 0;<br>
                let rotY = 0;
              </div>
              <p style="margin-top: 15px; color: #666;">
                ‚ö†Ô∏è <strong>Problema:</strong> No guardan la orientaci√≥n completa del objeto, solo √°ngulos acumulados.
              </p>
            </div>
          </div>

          <div>
            <div style="background: #f0fff4; padding: 20px; border-radius: 10px; border-left: 5px solid #48bb78;">
              <h4 style="color: #48bb78; margin-bottom: 15px;">‚úÖ Cuaterniones</h4>
              <div class="code-block">
                <span class="code-comment">// Guardamos la orientaci√≥n completa</span><br>
                let quaternion = new Quat();
              </div>
              <p style="margin-top: 15px; color: #666;">
                ‚úÖ <strong>Ventaja:</strong> Un solo objeto guarda toda la orientaci√≥n 3D del cubo.
              </p>
            </div>
          </div>
        </div>
      </div>

      <div style="background: #f0f4ff; padding: 30px; border-radius: 15px; margin-bottom: 30px;">
        <h3 style="color: #667eea; text-align: center; margin-bottom: 20px;">üñ±Ô∏è PASO 2: Cuando Mueves el Mouse (mouseMove)</h3>
        
        <div class="comparison-grid">
          <div>
            <div style="background: #fff5f5; padding: 20px; border-radius: 10px; border-left: 5px solid #f56565;">
              <h4 style="color: #f56565; margin-bottom: 15px;">‚ùå √Ångulos de Euler</h4>
              <div class="code-block">
                <span class="code-comment">// Calculamos movimiento</span><br>
                let dx = mouseX - anteriorX;<br>
                let dy = mouseY - anteriorY;<br><br>

                <span class="code-comment">// SUMA SIMPLE de √°ngulos</span><br>
                rotX = rotX + dx * 0.36;<br>
                rotY = rotY + dy * 0.36;
              </div>
              <div style="margin-top: 15px; background: white; padding: 15px; border-radius: 8px;">
                <p style="color: #e53e3e; font-weight: bold; margin-bottom: 10px;">‚ö†Ô∏è ¬øPor qu√© es problem√°tico?</p>
                <ul style="margin-left: 20px; color: #666;">
                  <li><strong>Suma simple:</strong> rotX += dx no representa rotaciones 3D reales</li>
                  <li><strong>Ejes fijos:</strong> Siempre rota sobre los ejes X e Y globales</li>
                  <li><strong>No intuitivo:</strong> Cuando el cubo est√° rotado, los movimientos son raros</li>
                </ul>
              </div>
            </div>
          </div>

          <div>
            <div style="background: #f0fff4; padding: 20px; border-radius: 10px; border-left: 5px solid #48bb78;">
              <h4 style="color: #48bb78; margin-bottom: 15px;">‚úÖ Cuaterniones</h4>
              <div class="code-block">
                <span class="code-comment">// Calculamos movimiento del mouse</span><br>
                let dx = mouseX - anteriorX;<br>
                let dy = mouseY - anteriorY;<br><br>

                <span class="code-comment">// Movimiento horizontal ‚Üí rotar sobre Y</span><br>
                let quatY = Quat.fromAxisAngle(
                  0, 1, 0,
                  dx * 0.01
                );<br><br>

                <span class="code-comment">// Movimiento vertical ‚Üí rotar sobre X</span><br>
                let quatX = Quat.fromAxisAngle(
                  1, 0, 0,
                  dy * 0.01
                );<br><br>

                <span class="code-comment">// MULTIPLICAMOS las rotaciones</span><br>
                let deltaQuat = quatY.multiply(quatX);<br><br>

                <span class="code-comment">// Aplicamos al cuaterni√≥n actual</span><br>
                quaternion = deltaQuat.multiply(quaternion);
                quaternion.normalize();
              </div>
              <div style="margin-top: 15px; background: white; padding: 15px; border-radius: 8px;">
                <p style="color: #38a169; font-weight: bold; margin-bottom: 10px;">‚úÖ ¬øPor qu√© funciona mejor?</p>
                <ul style="margin-left: 20px; color: #666;">
                  <li><strong>Multiplicaci√≥n:</strong> Compone rotaciones correctamente</li>
                  <li><strong>Rotaci√≥n incremental:</strong> Cada movimiento se aplica sobre la orientaci√≥n actual</li>
                  <li><strong>Natural:</strong> El cubo siempre sigue el mouse como esperas</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div style="background: #f0f4ff; padding: 30px; border-radius: 15px;">
        <h3 style="color: #667eea; text-align: center; margin-bottom: 20px;">üé® PASO 3: Dibujar el Cubo (dibuja)</h3>
        
        <div class="comparison-grid">
          <div>
            <div style="background: #fff5f5; padding: 20px; border-radius: 10px; border-left: 5px solid #f56565;">
              <h4 style="color: #f56565; margin-bottom: 15px;">‚ùå √Ångulos de Euler</h4>
              <div class="code-block">
                <span class="code-comment">// Aplicamos 2 rotaciones separadas</span><br>
                identidad(MatrizModelo);<br><br>
                
                <span class="code-comment">// ORDEN FIJO: primero Y, luego X</span><br>
                rotacionY(MatrizModelo, rotX);<br>
                rotacionX(MatrizModelo, rotY);<br>

                escalacion(MatrizModelo, 2, 2, 2);
              </div>
              <div style="margin-top: 15px; background: white; padding: 15px; border-radius: 8px;">
                <p style="color: #666;"><strong>Problema:</strong> Las rotaciones se aplican en ejes <span style="color: #e53e3e; font-weight: bold;">GLOBALES</span>, no en los ejes del cubo ya rotado.</p>
                <p style="color: #666; margin-top: 10px;">Resultado: <strong>Gimbal Lock</strong> en ciertos √°ngulos.</p>
              </div>
            </div>
          </div>

          <div>
            <div style="background: #f0fff4; padding: 20px; border-radius: 10px; border-left: 5px solid #48bb78;">
              <h4 style="color: #48bb78; margin-bottom: 15px;">‚úÖ Cuaterniones</h4>
              <div class="code-block">
                <span class="code-comment">// ‚úÖ Convertimos el cuaterni√≥n a matriz</span><br>
                identidad(MatrizModelo);<br>
                
                let rotMatrix = quaternion.toMatrix();<br><br>

                <span class="code-comment">// ‚úÖ Una sola multiplicaci√≥n</span><br>
                multiplica(MatrizModelo, MatrizModelo, rotMatrix);<br>

                escalacion(MatrizModelo, 2, 2, 2);
              </div>
              <div style="margin-top: 15px; background: white; padding: 15px; border-radius: 8px;">
                <p style="color: #666;"><strong>Ventaja:</strong> La matriz representa la <span style="color: #38a169; font-weight: bold;">orientaci√≥n COMPLETA</span> del cubo.</p>
                <p style="color: #666; margin-top: 10px;">Resultado: <strong>Rotaci√≥n suave</strong> en cualquier direcci√≥n.</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 15px; margin-top: 30px;">
        <h3 style="text-align: center; margin-bottom: 20px; font-size: 1.8em;">üéØ Resumen de la Diferencia Clave</h3>
        <div class="comparison-grid">
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h4 style="margin-bottom: 15px; font-size: 1.3em;">√Ångulos de Euler</h4>
            <p style="font-size: 1.1em; line-height: 1.8;">
              <strong>SUMA</strong> √°ngulos<br>
              ‚Üí rotX <span style="color: #ffd700;">+=</span> dx<br>
              ‚Üí rotY <span style="color: #ffd700;">+=</span> dy
            </p>
          </div>
          <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
            <h4 style="margin-bottom: 15px; font-size: 1.3em;">Cuaterniones</h4>
            <p style="font-size: 1.1em; line-height: 1.8;">
              <strong>MULTIPLICA</strong> rotaciones<br>
              ‚Üí q = delta <span style="color: #90ee90;">.multiply(</span>q<span style="color: #90ee90;">)</span><br>
              ‚Üí Composici√≥n correcta
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- SECCI√ìN 4: TABLA COMPARATIVA -->
    <div class="demo-section">
      <h2>‚öñÔ∏è Comparaci√≥n Detallada</h2>
      
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Aspecto</th>
            <th>√Ångulos de Euler</th>
            <th>Cuaterniones</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Representaci√≥n</strong></td>
            <td>3 √°ngulos (rotX, rotY, rotZ)</td>
            <td>4 n√∫meros (x, y, z, w)</td>
          </tr>
          <tr>
            <td><strong>Gimbal Lock</strong></td>
            <td><span class="cons">‚ùå S√≠ ocurre</span></td>
            <td><span class="pros">‚úÖ No ocurre</span></td>
          </tr>
          <tr>
            <td><strong>Interpolaci√≥n</strong></td>
            <td><span class="cons">‚ùå Incorrecta</span></td>
            <td><span class="pros">‚úÖ Suave (SLERP)</span></td>
          </tr>
          <tr>
            <td><strong>Composici√≥n</strong></td>
            <td><span class="cons">‚ùå Suma simple (rotX += dx)</span></td>
            <td><span class="pros">‚úÖ Multiplicaci√≥n correcta</span></td>
          </tr>
          <tr>
            <td><strong>Ejes de rotaci√≥n</strong></td>
            <td><span class="cons">‚ùå Siempre globales</span></td>
            <td><span class="pros">‚úÖ Din√°micos/locales</span></td>
          </tr>
          <tr>
            <td><strong>Eficiencia</strong></td>
            <td>Mediana</td>
            <td><span class="pros">‚úÖ Alta</span></td>
          </tr>
          <tr>
            <td><strong>Complejidad</strong></td>
            <td><span class="pros">‚úÖ Simple de entender</span></td>
            <td>Mediana</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- SECCI√ìN 5: GIMBAL LOCK -->
    <div class="demo-section">
      <h2>‚ö†Ô∏è El Problema del Gimbal Lock</h2>
      
      <div class="info-box" style="background: linear-gradient(135deg, #f56565 0%, #c53030 100%);">
        <h3>¬øQu√© es el Gimbal Lock?</h3>
        <p style="font-size: 1.1em;">
          Es una <strong>p√©rdida de un grado de libertad</strong> que ocurre cuando dos ejes de rotaci√≥n se alinean, haciendo imposible rotar en ciertas direcciones.
        </p>
      </div>

      <div class="step-by-step">
        <div class="step">
          <h4>Paso 1: Posici√≥n Inicial</h4>
          <p>El cubo est√° en su orientaci√≥n original. Todos los ejes funcionan correctamente.</p>
        </div>

        <div class="step">
          <h4>Paso 2: Rotamos 90¬∞ sobre Y</h4>
          <div class="code-block">
            rotX = 90¬∞<br>
            rotY = 0¬∞
          </div>
          <p>El cubo ahora mira hacia un lado.</p>
        </div>

        <div class="step">
          <h4>Paso 3: Intentamos rotar sobre X</h4>
          <div class="code-block">
            <span class="code-comment">// Primero rota sobre Y global</span><br>
            rotacionY(matriz, 90);  <br><br>
            <span class="code-comment">// ‚ö†Ô∏è Rota sobre X GLOBAL, no local</span><br>
            rotacionX(matriz, 30);  
          </div>
          <p><strong>Problema:</strong> El eje X local del cubo ya no es el eje X global. La rotaci√≥n es extra√±a e inesperada.</p>
        </div>

        <div class="step">
          <h4>Con Cuaterniones (Soluci√≥n)</h4>
          <div class="code-block">
            <span class="code-comment">// ‚úÖ La rotaci√≥n se aplica sobre la orientaci√≥n actual</span><br>
            <span class="code-comment">// ‚úÖ Los ejes "siguen" al cubo</span><br>
            quaternion = deltaQuat.multiply(quaternion)<br>
          </div>
        </div>
      </div>
    </div>

    <!-- SECCI√ìN 6: CU√ÅNDO USAR -->
    <div class="demo-section">
      <h2>ü§î ¬øCu√°ndo Usar Cada Uno?</h2>

      <div class="comparison-grid">
        <div>
          <div class="info-box" style="background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);">
            <h3>üìê Usa √Ångulos de Euler</h3>
            <ul style="margin-left: 20px;">
              <li>Solo rotas en 1 o 2 ejes fijos</li>
              <li>No necesitas rotaciones complejas</li>
              <li>Rotaciones limitadas conocidas</li>
              <li><strong>Ejemplo:</strong> C√°mara FPS (solo yaw/pitch)</li>
            </ul>
          </div>
        </div>

        <div>
          <div class="info-box">
            <h3>üéØ Usa Cuaterniones</h3>
            <ul style="margin-left: 20px;">
              <li>Rotaciones libres en 3D</li>
              <li>Necesitas evitar Gimbal Lock</li>
              <li>Interpolaci√≥n suave entre rotaciones</li>
              <li><strong>Ejemplo:</strong> Controles 3D, animaciones, f√≠sica</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- FOOTER -->
    <div style="text-align: center; padding: 40px; color: white;">
      <p style="font-size: 1.2em;">¬øListo para implementar cuaterniones en tu proyecto? üöÄ</p>
      <p style="margin-top: 10px; opacity: 0.8;">Tutorial interactivo - 2024</p>
    </div>
  </div>

  <script>
    // CLASE CUATERNI√ìN
    class Quat {
      constructor(x = 0, y = 0, z = 0, w = 1) {
        this.x = x; this.y = y; this.z = z; this.w = w;
      }
      static fromAxisAngle(ax, ay, az, angle) {
        const half = angle * 0.5, s = Math.sin(half);
        return new Quat(ax * s, ay * s, az * s, Math.cos(half));
      }
      multiply(q) {
        return new Quat(
          this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,
          this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,
          this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w,
          this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z
        );
      }
      normalize() {
        const len = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w);
        if (len > 0) { this.x /= len; this.y /= len; this.z /= len; this.w /= len; }
        return this;
      }
      toMatrix() {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const x2 = x+x, y2 = y+y, z2 = z+z;
        const xx = x*x2, xy = x*y2, xz = x*z2;
        const yy = y*y2, yz = y*z2, zz = z*z2;
        const wx = w*x2, wy = w*y2, wz = w*z2;
        return [1-(yy+zz), xy+wz, xz-wy, 0, xy-wz, 1-(xx+zz), yz+wx, 0, xz+wy, yz-wx, 1-(xx+yy), 0, 0, 0, 0, 1];
      }
    }

    // FUNCIONES MATRIZ
    function identity() { return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
    function multiply(a, b) {
      let r = [];
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          let s = 0;
          for (let k = 0; k < 4; k++) s += a[i + k*4] * b[k + j*4];
          r[i + j*4] = s;
        }
      }
      return r;
    }
    function rotX(angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      return [1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1];
    }
    function rotY(angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      return [c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1];
    }

    // WEBGL SETUP
    function setupGL(canvas) {
      const gl = canvas.getContext('webgl');
      
      const vs = `
        attribute vec3 pos;
        attribute vec3 col;
        uniform mat4 proj;
        uniform mat4 model;
        varying vec3 vCol;
        void main() {
          vCol = col;
          gl_Position = proj * model * vec4(pos, 1.0);
        }
      `;
      
      const fs = `
        precision mediump float;
        varying vec3 vCol;
        void main() {
          gl_FragColor = vec4(vCol, 1.0);
        }
      `;
      
      const vsh = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vsh, vs);
      gl.compileShader(vsh);
      
      const fsh = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fsh, fs);
      gl.compileShader(fsh);
      
      const prog = gl.createProgram();
      gl.attachShader(prog, vsh);
      gl.attachShader(prog, fsh);
      gl.linkProgram(prog);
      gl.useProgram(prog);
      
      const verts = new Float32Array([
        -1,-1,1, 1,-1,1, 1,1,1, -1,1,1,
        -1,1,-1, 1,1,-1, 1,-1,-1, -1,-1,-1,
        -1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1,
        1,-1,1, 1,-1,-1, 1,1,-1, 1,1,1,
        -1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1,
        -1,1,1, 1,1,1, 1,1,-1, -1,1,-1
      ]);
      
      const colors = new Float32Array([
        1,0,1, 1,0,1, 1,0,1, 1,0,1,
        1,1,0, 1,1,0, 1,1,0, 1,1,0,
        0,1,1, 0,1,1, 0,1,1, 0,1,1,
        1,0,0, 1,0,0, 1,0,0, 1,0,0,
        0,0,1, 0,0,1, 0,0,1, 0,0,1,
        0,1,0, 0,1,0, 0,1,0, 0,1,0
      ]);
      
      const indices = new Uint16Array([
        0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11,
        12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23
      ]);
      
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
      const posLoc = gl.getAttribLocation(prog, 'pos');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
      
      const cbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      const colLoc = gl.getAttribLocation(prog, 'col');
      gl.enableVertexAttribArray(colLoc);
      gl.vertexAttribPointer(colLoc, 3, gl.FLOAT, false, 0, 0);
      
      const ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
      
      gl.enable(gl.DEPTH_TEST);
      
      const proj = [0.4,0,0,0, 0,0.4,0,0, 0,0,-0.4,0, 0,0,0,1];
      gl.uniformMatrix4fv(gl.getUniformLocation(prog, 'proj'), false, proj);
      
      return { gl, prog };
    }

    // EULER CUBE
    const eulerCanvas = document.getElementById('canvasEuler');
    const euler = setupGL(eulerCanvas);
    let eulerRotX = 0, eulerRotY = 0;
    let eulerDragging = false, eulerLastX, eulerLastY;

    eulerCanvas.addEventListener('mousedown', e => {
      eulerDragging = true;
      eulerLastX = e.offsetX;
      eulerLastY = e.offsetY;
    });
    eulerCanvas.addEventListener('mouseup', () => eulerDragging = false);
    eulerCanvas.addEventListener('mouseleave', () => eulerDragging = false);
    eulerCanvas.addEventListener('mousemove', e => {
      if (!eulerDragging) return;
      const dx = e.offsetX - eulerLastX;
      const dy = e.offsetY - eulerLastY;
      eulerRotX -= dx * 0.01;  // Invertido para seguir el mouse
      eulerRotY -= dy * 0.01;  // Invertido para seguir el mouse
      eulerLastX = e.offsetX;
      eulerLastY = e.offsetY;
      document.getElementById('eulerX').textContent = (eulerRotX * 57.3).toFixed(1) + '¬∞';
      document.getElementById('eulerY').textContent = (eulerRotY * 57.3).toFixed(1) + '¬∞';
    });

    function drawEuler() {
      euler.gl.clear(euler.gl.COLOR_BUFFER_BIT | euler.gl.DEPTH_BUFFER_BIT);
      let mat = multiply(rotY(eulerRotX), rotX(eulerRotY));
      euler.gl.uniformMatrix4fv(euler.gl.getUniformLocation(euler.prog, 'model'), false, mat);
      euler.gl.drawElements(euler.gl.TRIANGLES, 36, euler.gl.UNSIGNED_SHORT, 0);
      requestAnimationFrame(drawEuler);
    }
    drawEuler();

    // QUATERNION CUBE
    const quatCanvas = document.getElementById('canvasQuat');
    const quat = setupGL(quatCanvas);
    let quaternion = new Quat();
    let quatDragging = false, quatLastX, quatLastY;

    quatCanvas.addEventListener('mousedown', e => {
      quatDragging = true;
      quatLastX = e.offsetX;
      quatLastY = e.offsetY;
    });
    quatCanvas.addEventListener('mouseup', () => quatDragging = false);
    quatCanvas.addEventListener('mouseleave', () => quatDragging = false);
    quatCanvas.addEventListener('mousemove', e => {
      if (!quatDragging) return;
      const dx = e.offsetX - quatLastX;
      const dy = e.offsetY - quatLastY;
      const quatY = Quat.fromAxisAngle(0, 1, 0, dx * 0.01);
      const quatX = Quat.fromAxisAngle(1, 0, 0, dy * 0.01);
      const delta = quatY.multiply(quatX);
      quaternion = delta.multiply(quaternion).normalize();
      quatLastX = e.offsetX;
      quatLastY = e.offsetY;
      document.getElementById('quatValues').textContent = 
        `${quaternion.x.toFixed(2)}, ${quaternion.y.toFixed(2)}, ${quaternion.z.toFixed(2)}, ${quaternion.w.toFixed(2)}`;
    });

    function drawQuat() {
      quat.gl.clear(quat.gl.COLOR_BUFFER_BIT | quat.gl.DEPTH_BUFFER_BIT);
      const mat = quaternion.toMatrix();
      quat.gl.uniformMatrix4fv(quat.gl.getUniformLocation(quat.prog, 'model'), false, mat);
      quat.gl.drawElements(quat.gl.TRIANGLES, 36, quat.gl.UNSIGNED_SHORT, 0);
      requestAnimationFrame(drawQuat);
    }
    drawQuat();
  </script>
</body>
</html>
