<!DOCTYPE HTML>
<html>
<head>
  <style type="text/css">
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      background-color: #2a2a2a;
      height: 100vh;
      overflow: hidden;
    }
    
    #content {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    
    #opciones {
      width: 280px;
      background-color: #3a3a3a;
      padding: 20px;
      overflow-y: auto;
      border-right: 2px solid #555;
      box-shadow: 2px 0 10px rgba(0,0,0,0.5);
    }
    
    #canvas-holder {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
    }
    
    #webglcanvas {
      width: 90%;
      height: 90%;
      max-width: 1200px;
      max-height: 900px;
      border: 3px solid #555;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.7);
    }
    
    fieldset {
      border: 1px solid #555;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: #424242;
    }
    
    legend {
      color: #fff;
      font-weight: bold;
      padding: 0 10px;
    }
    
    button {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.3s;
      text-align: left;
      padding-left: 12px;
    }
    
    button:hover {
      background-color: #45a049;
      transform: translateX(5px);
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    #reset {
      background-color: #f44336;
      margin-top: 15px;
      font-weight: bold;
    }
    
    #reset:hover {
      background-color: #da190b;
    }
    
    button.activo {
      background-color: #2196F3;
    }
    
    button.activo:hover {
      background-color: #0b7dda;
    }
    
    .button-group {
      margin-bottom: 8px;
    }
    
    h3 {
      margin: 0;
      color: #64B5F6;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      color: #888;
      background: rgba(0,0,0,0.7);
      padding: 30px;
      border-radius: 8px;
      z-index: 100;
    }
    
    h2 {
      color: #64B5F6;
      text-align: center;
      padding: 15px;
      border-bottom: 2px solid #555;
      margin-bottom: 15px;
      font-size: 16px;
    }
  </style>
  <title>Visor GLB con Cuaterniones - WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
</head>
<body>
  <div id="content">
    <div id="opciones">
      <h2>Panel de Control</h2>
      <fieldset>
        <legend><h3>Cámara</h3></legend>
        <div class="button-group">
          <button id="rotarArriba"> Arriba</button>
          <button id="rotarAbajo"> Abajo</button>
          <button id="rotarIzquierda"> Izquierda</button>
          <button id="rotarDerecha"> Derecha</button>
        </div>
      </fieldset>
      
      <fieldset>
        <legend><h3>Zoom</h3></legend>
        <div class="button-group">
          <button id="zoomIn"> + Acercar</button>
          <button id="zoomOut"> - Alejar</button>
        </div>
      </fieldset>
      
      <fieldset>
        <legend><h3>Rotación</h3></legend>
        <div class="button-group">
          <button id="rotarX"> Eje X</button>
          <button id="rotarY"> Eje Y</button>
          <button id="rotarZ"> Eje Z</button>
        </div>
      </fieldset>
      
      <button id="reset"> Reiniciar</button>
    </div>
    
    <div id="canvas-holder">
      <canvas id="webglcanvas" style="border: none; background: linear-gradient(to bottom, #87CEEB, #E0F6FF);" width="500" height="500"></canvas>
      <div id="loading">Cargando modelo 3D...</div>
    </div>
  </div>

  <!-- Shaders -->
  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec3 aNormales;
    layout(location = 2) in vec2 aTexCoords;
    out vec3 vNormales;
    out vec3 vPosicion;
    out vec2 vTexCoords;
    
    void main() {
      vNormales = mat3(uMatrizModelo) * aNormales;
      vec4 posicionMundo = uMatrizModelo * vec4(aVertices, 1.0);
      vPosicion = posicionMundo.xyz;
      vTexCoords = aTexCoords;
      gl_Position = uMatrizProyeccion * uMatrizVista * posicionMundo;
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec3 vNormales;
    in vec3 vPosicion;
    in vec2 vTexCoords;
    out vec4 color;
    uniform sampler2D uTextura;
    uniform bool uTieneTextura;
    
    void main() {
      vec3 normal = normalize(vNormales);
      vec3 luzDir = normalize(vec3(1.0, 1.0, 1.0));
      float difusa = max(dot(normal, luzDir), 0.0);
      vec3 ambiente = vec3(0.3, 0.3, 0.3);
      
      // Usar textura si existe, sino color por defecto
      vec3 colorBase = vec3(0.8, 0.6, 0.4);
      if (uTieneTextura) {
        colorBase = texture(uTextura, vTexCoords).rgb;
      }
      
      vec3 colorFinal = colorBase * (ambiente + difusa * 0.7);
      color = vec4(colorFinal, 1.0);
    }
  </script>

  <script>
    "use strict";

    /* Variables globales */
    let canvas;
    let programaID;
    let gl;
    let modeloGLB;
    let arcBall;

    /* Variables Uniformes */
    let uMatrizProyeccion;
    let uMatrizVista;
    let uMatrizModelo;
    let uTextura;
    let uTieneTextura;

    /* Matrices */
    let MatrizProyeccion = new Array(16);
    let MatrizVista = new Array(16);
    let MatrizModelo = new Array(16);

    /* Para la interacción */
    let MatrizRotacion = new Array(16);
    let B = new Array(16);
    let boton_izq_presionado = false;
    let boton_der_presionado = false;
    let traslacionX = 0;
    let traslacionY = 0;
    let ultimoX = 0;
    let ultimoY = 0;

    /* Para las animaciones de cámara */
    let anguloVertical = 0;
    let anguloHorizontal = 0;
    let distanciaCamara = 10;
    let rotacionObjetoX = 0;
    let rotacionObjetoY = 0;
    let rotacionObjetoZ = 0;

    /* Flags para rotación continua y zoom */
    let rotarXActivo = false;
    let rotarYActivo = false;
    let rotarZActivo = false;
    let zoomInActivo = false;
    let zoomOutActivo = false;
    let camaraArribaActiva = false;
    let camaraAbajoActiva = false;
    let camaraIzquierdaActiva = false;
    let camaraDerechaActiva = false;

    /* Velocidad de animación */
    const VELOCIDAD_ROTACION = 2;
    const VELOCIDAD_ZOOM = 0.2;
    const VELOCIDAD_CAMARA = 0.4;

    /***************************************************************************/
    /* GLTF/GLB Loader Mejorado                                                */
    /***************************************************************************/
    class GLTFLoader {
      async load(url) {
        try {
          console.log('Intentando cargar:', url);
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const arrayBuffer = await response.arrayBuffer();
          console.log('Archivo cargado, tamaño:', arrayBuffer.byteLength, 'bytes');
          
          return this.parse(arrayBuffer);
        } catch (error) {
          console.error('Error en load():', error);
          throw error;
        }
      }

      parse(arrayBuffer) {
        try {
          const dataView = new DataView(arrayBuffer);
          
          // Leer header GLB
          const magic = dataView.getUint32(0, true);
          console.log('Magic number:', magic.toString(16));
          
          if (magic !== 0x46546C67) { // "glTF"
            throw new Error('No es un archivo GLB válido (magic number incorrecto)');
          }

          const version = dataView.getUint32(4, true);
          const length = dataView.getUint32(8, true);
          console.log('Versión GLB:', version, 'Tamaño total:', length);

          // Leer chunk JSON
          const jsonChunkLength = dataView.getUint32(12, true);
          const jsonChunkType = dataView.getUint32(16, true);
          console.log('JSON chunk length:', jsonChunkLength);
          
          const jsonData = new Uint8Array(arrayBuffer, 20, jsonChunkLength);
          const jsonString = new TextDecoder().decode(jsonData);
          const gltf = JSON.parse(jsonString);
          console.log('GLTF parseado:', gltf);

          // Leer chunk BIN (puede haber múltiples)
          const binChunkStart = 20 + jsonChunkLength;
          const binChunkLength = dataView.getUint32(binChunkStart, true);
          const binData = new Uint8Array(arrayBuffer, binChunkStart + 8, binChunkLength);
          console.log('BIN chunk length:', binChunkLength);

          // Extraer texturas si existen
          let texturas = null;
          if (gltf.images && gltf.images.length > 0) {
            console.log('Encontradas', gltf.images.length, 'imágenes');
            texturas = this.parseTexturas(gltf, binData);
          }

          const geometria = this.parseGeometry(gltf, binData);
          geometria.texturas = texturas;
          
          return geometria;
        } catch (error) {
          console.error('Error en parse():', error);
          throw error;
        }
      }

      parseTexturas(gltf, binData) {
        try {
          const texturas = [];
          
          for (let i = 0; i < gltf.images.length; i++) {
            const image = gltf.images[i];
            console.log('Procesando imagen:', i, image);
            
            if (image.bufferView !== undefined) {
              const bufferView = gltf.bufferViews[image.bufferView];
              const offset = (bufferView.byteOffset || 0);
              const tamano = bufferView.byteLength;
              
              const imagenData = new Uint8Array(binData.buffer, binData.byteOffset + offset, tamano);
              const blob = new Blob([imagenData], { type: image.mimeType || 'image/png' });
              const url = URL.createObjectURL(blob);
              
              texturas.push({
                nombre: image.name || 'textura_' + i,
                url: url,
                mimeType: image.mimeType || 'image/png'
              });
              
              console.log('Textura cargada:', texturas[i].nombre);
            }
          }
          
          return texturas.length > 0 ? texturas : null;
        } catch (error) {
          console.error('Error al extraer texturas:', error);
          return null;
        }
      }

      parseGeometry(gltf, binData) {
        try {
          console.log('Parseando geometría...');
          
          if (!gltf.meshes || gltf.meshes.length === 0) {
            throw new Error('No se encontraron meshes en el archivo GLB');
          }

          const mesh = gltf.meshes[0];
          console.log('Mesh encontrado:', mesh);
          
          if (!mesh.primitives || mesh.primitives.length === 0) {
            throw new Error('No se encontraron primitivas en el mesh');
          }

          const primitive = mesh.primitives[0];
          console.log('Primitive:', primitive);
          
          // Obtener posiciones (vértices)
          const positions = this.getAccessorData(gltf, binData, primitive.attributes.POSITION);
          console.log('Vértices cargados:', positions.length / 3);
          
          // Obtener normales (pueden no existir)
          let normals = null;
          if (primitive.attributes.NORMAL !== undefined) {
            normals = this.getAccessorData(gltf, binData, primitive.attributes.NORMAL);
            console.log('Normales cargadas:', normals.length / 3);
          } else {
            // Generar normales si no existen
            console.log('Generando normales...');
            normals = this.generateNormals(positions);
          }
          
          // Obtener coordenadas de textura (si existen)
          let texCoords = null;
          if (primitive.attributes.TEXCOORD_0 !== undefined) {
            texCoords = this.getAccessorData(gltf, binData, primitive.attributes.TEXCOORD_0);
            console.log('Coordenadas de textura cargadas:', texCoords.length / 2);
          }
          
          // Obtener índices
          let indices = null;
          if (primitive.indices !== undefined) {
            indices = this.getAccessorData(gltf, binData, primitive.indices);
            console.log('Índices cargados:', indices.length);
          } else {
            console.log('Sin índices, usando vértices directamente');
          }
          
          // Obtener información de materiales
          let materialInfo = null;
          if (primitive.material !== undefined && gltf.materials) {
            const material = gltf.materials[primitive.material];
            materialInfo = {
              name: material.name || 'material',
              doubleSided: material.doubleSided || false,
              pbr: material.pbrMetallicRoughness || {}
            };
            console.log('Material encontrado:', materialInfo);
          }

          return {
            vertices: positions,
            normales: normals,
            texCoords: texCoords,
            indices: indices,
            material: materialInfo
          };
        } catch (error) {
          console.error('Error en parseGeometry():', error);
          throw error;
        }
      }

      getAccessorData(gltf, binData, accessorIndex) {
        try {
          const accessor = gltf.accessors[accessorIndex];
          const bufferView = gltf.bufferViews[accessor.bufferView];
          
          const offset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
          const length = accessor.count * this.getComponentCount(accessor.type);
          
          const TypedArray = this.getTypedArray(accessor.componentType);
          const data = new TypedArray(binData.buffer, binData.byteOffset + offset, length);
          
          return data;
        } catch (error) {
          console.error('Error en getAccessorData():', error);
          throw error;
        }
      }

      generateNormals(positions) {
        const normals = new Float32Array(positions.length);
        
        for (let i = 0; i < positions.length; i += 9) {
          const v1 = [positions[i], positions[i+1], positions[i+2]];
          const v2 = [positions[i+3], positions[i+4], positions[i+5]];
          const v3 = [positions[i+6], positions[i+7], positions[i+8]];
          
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          
          const normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          
          const len = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
          if (len > 0) {
            normal[0] /= len;
            normal[1] /= len;
            normal[2] /= len;
          }
          
          for (let j = 0; j < 3; j++) {
            normals[i + j*3] = normal[0];
            normals[i + j*3 + 1] = normal[1];
            normals[i + j*3 + 2] = normal[2];
          }
        }
        
        return normals;
      }

      getComponentCount(type) {
        const counts = {
          'SCALAR': 1, 'VEC2': 2, 'VEC3': 3, 'VEC4': 4,
          'MAT2': 4, 'MAT3': 9, 'MAT4': 16
        };
        return counts[type];
      }

      getTypedArray(componentType) {
        const types = {
          5120: Int8Array, 5121: Uint8Array,
          5122: Int16Array, 5123: Uint16Array,
          5125: Uint32Array, 5126: Float32Array
        };
        return types[componentType];
      }
    }

    /***************************************************************************/
    /* Se crean, compilan y enlazan los programas Shader                       */
    /***************************************************************************/
    function compilaEnlazaLosShaders() {
      let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);
      if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeVertice));
      }

      let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);
      if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeFragmento));
      }

      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice); 
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
         console.error(gl.getProgramInfoLog(programaID));
      }

      gl.useProgram(programaID);
    }

    /***************************************************************************/
    /* Transformaciones mediante matrices                                      */
    /***************************************************************************/
    function toRadians(grados) {
      return grados * Math.PI / 180;
    }

    function identidad(r) {
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function traslacion(matriz, tx, ty, tz) {
      let r = new Array(16);
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function escalacion(matriz, sx, sy, sz) { 
      let r = new Array(16);
      r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
      r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
      r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function rotacionX(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
      r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
      r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r); 
    }

    function rotacionY(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
      r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
      r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionZ(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
      r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
      r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function perspective(r, fovy, aspecto, cerca, lejos) {
      let ang = fovy * 0.5;
      let f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
      r[0] = f/aspecto; r[4] = 0; r[ 8] =                                  0; r[12] =                                       0;
      r[1] =         0; r[5] = f; r[ 9] =                                  0; r[13] =                                       0;
      r[2] =         0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] =  -2.0 * lejos * cerca / (lejos - cerca);
      r[3] =         0; r[7] = 0; r[11] =                              - 1.0; r[15] =                                       0;
    }

    function lookAt(matriz, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
      let fx = centerX - eyeX;
      let fy = centerY - eyeY;
      let fz = centerZ - eyeZ;
      let rlf = 1.0 / Math.sqrt(fx*fx + fy*fy + fz*fz);
      fx *= rlf; fy *= rlf; fz *= rlf;

      let sx = fy * upZ - fz * upY;
      let sy = fz * upX - fx * upZ;
      let sz = fx * upY - fy * upX;
      let rls = 1.0 / Math.sqrt(sx*sx + sy*sy + sz*sz);
      sx *= rls; sy *= rls; sz *= rls;

      let ux = sy * fz - sz * fy;
      let uy = sz * fx - sx * fz;
      let uz = sx * fy - sy * fx;

      matriz[0] = sx; matriz[4] = ux; matriz[ 8] = -fx; matriz[12] = 0;
      matriz[1] = sy; matriz[5] = uy; matriz[ 9] = -fy; matriz[13] = 0;
      matriz[2] = sz; matriz[6] = uz; matriz[10] = -fz; matriz[14] = 0;
      matriz[3] = 0;  matriz[7] = 0;  matriz[11] =   0; matriz[15] = 1;

      traslacion(matriz, -eyeX, -eyeY, -eyeZ);
    }

    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++){
        for (j = 0; j < 4; j++){
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }

    /***************************************************************************/
    /* La Clase Vector3                                                        */
    /***************************************************************************/
    class Vector3 {
      constructor(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      }

      mas(v2) {
        return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z));
      }

      menos(v2) {
        return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z));
      }

      producto_vectorial(v2) {
        let r = new Vector3();
        r.x = (this.y * v2.z) - (this.z * v2.y);
        r.y = (this.z * v2.x) - (this.x * v2.z);
        r.z = (this.x * v2.y) - (this.y * v2.x);
        return r;
      }

      producto_escalar(v2) {
        return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z);
      }

      longitud() {
        return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
      }

      normaliza() {
        let l = this.longitud();
        if (l > 0 ) {
          this.x = this.x / l;
          this.y = this.y / l;
          this.z = this.z / l;
        }
      }
    }

    /***************************************************************************/
    /* ArcBall                                                                 */
    /***************************************************************************/
    let Punto2f = function(x, y) {
      this.x = x;
      this.y = y;
    }

    class ArcBall {
      constructor(w, h) {
        this.Epsilon = 1.0e-5;
        this.U = new Vector3();
        this.V = new Vector3();
        this.ajusta(w, h);
      }

      ajusta(w, h) {
        if (!((w > 1.0) && (h > 1.0)))
          console.error("ERROR en ArcBall.ajusta");

        this.ajustaAncho = 2.0 / (w - 1.0);
        this.ajustaAlto = 2.0 / (h - 1.0);
      }

      obtieneVector(vector, x, y) {
        let temp = new Punto2f(x, y);
        temp.x = (temp.x * this.ajustaAncho) - 1.0;
        temp.y = 1.0 - (temp.y * this.ajustaAlto);

        let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);

        if (longitud2 > 1.0) {
          let norma = (1.0 / Math.sqrt(longitud2));
          vector.x = temp.x * norma;
          vector.y = temp.y * norma;
          vector.z = 0.0;
        } else {
          vector.x = temp.x;
          vector.y = temp.y;
          vector.z = Math.sqrt(1.0 - longitud2);
        }
      }

      primerPunto(x, y) {
        this.obtieneVector(this.U, x, y);
      }

      segundoPunto(x, y) {
        let q = new Cuaternion(0, 0, 0, 0);
        this.obtieneVector(this.V, x, y);

        if (q != null) {
          let Normal = this.U.producto_vectorial(this.V);

          if (Normal.longitud() > this.Epsilon) {
            q.x = Normal.x;
            q.y = Normal.y;
            q.z = Normal.z;
            q.w = this.U.producto_escalar(this.V);
          } else {
            q.x = q.y = q.z = q.w = 0.0;
          }
        }
        return q;
      }
    }

    /***************************************************************************/
    /* Cuaternion                                                              */
    /***************************************************************************/
    class Cuaternion {
      constructor(w, x, y, z) {
        this.w = w || 0;
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      }

      static rota2(a, q) {
        let d, s;
        d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w);
        s = (d > 0.0) ? (2.0 / d) : 0.0;
        a[0] =  1.0 - (q.y*q.y + q.z*q.z) * s; a[4] =        (q.x*q.y - q.w*q.z) * s; a[8]  =        (q.x*q.z + q.w*q.y) * s; a[12] = 0;
        a[1] =        (q.x*q.y + q.w*q.z) * s; a[5] = 1.0  - (q.x*q.x + q.z*q.z) * s; a[9]  =        (q.y*q.z - q.w*q.x) * s; a[13] = 0;
        a[2] =        (q.x*q.z - q.w*q.y) * s; a[6] =        (q.y*q.z + q.w*q.x) * s; a[10] = 1.0  - (q.x*q.x + q.y*q.y) * s; a[14] = 0;
        a[3] =                              0; a[7] =                              0; a[11] =                              0; a[15] = 1;
      }
    }

    /***************************************************************************/
    /* Modelo GLB                                                              */
    /***************************************************************************/
    class ModeloGLB {
      constructor(gl, geometria) {
        console.log('Creando ModeloGLB...');
        
        this.gl = gl;
        this.modeloVAO = gl.createVertexArray();
        gl.bindVertexArray(this.modeloVAO);

        // Vertices
        let codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(gl.ARRAY_BUFFER, geometria.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        // Normales
        let codigoNormales = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoNormales);
        gl.bufferData(gl.ARRAY_BUFFER, geometria.normales, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

        // Coordenadas de Textura (si existen)
        if (geometria.texCoords) {
          let codigoTexCoords = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, codigoTexCoords);
          gl.bufferData(gl.ARRAY_BUFFER, geometria.texCoords, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(2);
          gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
          this.tieneTexCoords = true;
          console.log('Coordenadas de textura configuradas');
        } else {
          this.tieneTexCoords = false;
          console.log('Sin coordenadas de textura');
        }

        // Cargar texturas si existen
        this.texturaGL = null;
        if (geometria.texturas && geometria.texturas.length > 0) {
          console.log('Cargando texturas...');
          this.texturaGL = this.crearTexturaDesdeURL(geometria.texturas[0].url);
        }

        // Indices
        this.tieneIndices = false;
        this.tipoIndice = gl.UNSIGNED_SHORT;
        
        if (geometria.indices) {
          this.tieneIndices = true;
          
          // Determinar el tipo de índice
          if (geometria.indices instanceof Uint32Array) {
            this.tipoIndice = gl.UNSIGNED_INT;
          } else if (geometria.indices instanceof Uint16Array) {
            this.tipoIndice = gl.UNSIGNED_SHORT;
          } else if (geometria.indices instanceof Uint8Array) {
            this.tipoIndice = gl.UNSIGNED_BYTE;
          }
          
          let codigoDeIndices = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometria.indices, gl.STATIC_DRAW);
          this.conteoIndices = geometria.indices.length;
          console.log('Índices:', this.conteoIndices, 'Tipo:', this.tipoIndice);
        } else {
          this.conteoIndices = geometria.vertices.length / 3;
          console.log('Sin índices, vértices directos:', this.conteoIndices);
        }

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        
        console.log('ModeloGLB creado exitosamente');
      }

      crearTexturaDesdeURL(url) {
        const gl = this.gl;
        const textura = gl.createTexture();
        
        const imagen = new Image();
        imagen.onload = function() {
          gl.bindTexture(gl.TEXTURE_2D, textura);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          console.log('Textura cargada en WebGL');
        };
        
        imagen.onerror = function() {
          console.error('Error al cargar imagen de textura:', url);
        };
        
        imagen.src = url;
        return textura;
      }

      dibuja(gl) {
        gl.bindVertexArray(this.modeloVAO);
        if (this.tieneIndices) {
          gl.drawElements(gl.TRIANGLES, this.conteoIndices, this.tipoIndice, 0);
        } else {
          gl.drawArrays(gl.TRIANGLES, 0, this.conteoIndices);
        }
        gl.bindVertexArray(null);
      }
    }

    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/
    function mouseDown(event) {
      let posx = event.x != undefined ? event.x : event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      let posy = event.y != undefined ? event.y : event.clientY + document.body.scrollTop + document.documentElement.scrollTop;

      posx = posx - canvas.offsetLeft;
      posy = posy - canvas.offsetTop;

      if (event.button === 0) {
        // Botón izquierdo: arcball
        B = MatrizRotacion.slice();
        arcBall.primerPunto(posx, posy);
        boton_izq_presionado = true;
      } else if (event.button === 2) {
        // Botón derecho: pan/translate
        boton_der_presionado = true;
        ultimoX = posx;
        ultimoY = posy;
        event.preventDefault();
      }
      return false;
    }

    function mouseUp(e){
      boton_izq_presionado = false;
      boton_der_presionado = false;
    }

    function mouseMove(event) {
      let posx = event.x != undefined ? event.x : event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      let posy = event.y != undefined ? event.y : event.clientY + document.body.scrollTop + document.documentElement.scrollTop;

      posx = posx - canvas.offsetLeft;
      posy = posy - canvas.offsetTop;

      if (boton_izq_presionado) {
        // Arcball rotation
        let q = arcBall.segundoPunto(posx, posy);
        Cuaternion.rota2(MatrizRotacion, q);
        multiplica(MatrizRotacion, MatrizRotacion, B);
      } else if (boton_der_presionado) {
        // Pan/translate (intuitive direction)
        let deltaX = posx - ultimoX;
        let deltaY = posy - ultimoY;
        traslacionX += deltaX * 0.01;  // Mismo sentido
        traslacionY -= deltaY * 0.01;  // Invertir Y porque pantalla va de arriba a abajo
        
        ultimoX = posx;
        ultimoY = posy;
      }
    }

    function mouseWheel(event) {
      event.preventDefault();
      if (event.deltaY < 0) {
        // Scroll up: zoom in
        distanciaCamara = Math.max(2, distanciaCamara - VELOCIDAD_ZOOM * 3);
      } else {
        // Scroll down: zoom out
        distanciaCamara = Math.min(50, distanciaCamara + VELOCIDAD_ZOOM * 3);
      }
      return false;
    }

    /***************************************************************************/
    /* Funciones de Animación                                                  */
    /****************************************************************************/
    function actualizaBotonActivo(idBoton, activo) {
      const boton = document.getElementById(idBoton);
      if (activo) {
        boton.classList.add('activo');
      } else {
        boton.classList.remove('activo');
      }
    }

    function animarCamaraArriba() {
      camaraArribaActiva = !camaraArribaActiva;
      actualizaBotonActivo('rotarArriba', camaraArribaActiva);
    }

    function animarCamaraAbajo() {
      camaraAbajoActiva = !camaraAbajoActiva;
      actualizaBotonActivo('rotarAbajo', camaraAbajoActiva);
    }

    function animarCamaraIzquierda() {
      camaraIzquierdaActiva = !camaraIzquierdaActiva;
      actualizaBotonActivo('rotarIzquierda', camaraIzquierdaActiva);
    }

    function animarCamaraDerecha() {
      camaraDerechaActiva = !camaraDerechaActiva;
      actualizaBotonActivo('rotarDerecha', camaraDerechaActiva);
    }

    function animarZoomIn() {
      zoomInActivo = !zoomInActivo;
      actualizaBotonActivo('zoomIn', zoomInActivo);
    }

    function animarZoomOut() {
      zoomOutActivo = !zoomOutActivo;
      actualizaBotonActivo('zoomOut', zoomOutActivo);
    }

    function animarRotacionZ() {
      rotarZActivo = !rotarZActivo;
      actualizaBotonActivo('rotarZ', rotarZActivo);
    }

    function iniciaRotacionX() {
      rotarXActivo = !rotarXActivo;
      actualizaBotonActivo('rotarX', rotarXActivo);
    }

    function detienRotacionX() {
      // No hacer nada - la rotación se controla con toggle
    }

    function iniciaRotacionY() {
      rotarYActivo = !rotarYActivo;
      actualizaBotonActivo('rotarY', rotarYActivo);
    }

    function detienRotacionY() {
      // No hacer nada - la rotación se controla con toggle
    }

    function actualizarCamara() {
      // Calcular posición de la cámara en coordenadas esféricas
      let radianes_h = toRadians(anguloHorizontal);
      let radianes_v = toRadians(anguloVertical);
      
      let camX = distanciaCamara * Math.cos(radianes_v) * Math.sin(radianes_h);
      let camY = distanciaCamara * Math.sin(radianes_v);
      let camZ = distanciaCamara * Math.cos(radianes_v) * Math.cos(radianes_h);

      identidad(MatrizVista);
      lookAt(MatrizVista, camX, camY, camZ, 0, 0, 0, 0, 1, 0);
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
    }

    /***************************************************************************/
    /* Dibuja                                                                  */
    /***************************************************************************/
    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      if (!modeloGLB) {
        requestAnimationFrame(dibuja);
        return;
      }

      // Actualizar rotaciones continuas y zoom
      if (rotarXActivo) rotacionObjetoX += VELOCIDAD_ROTACION;
      if (rotarYActivo) rotacionObjetoY += VELOCIDAD_ROTACION;
      if (rotarZActivo) rotacionObjetoZ += VELOCIDAD_ROTACION;
      if (zoomInActivo) distanciaCamara = Math.max(2, distanciaCamara - VELOCIDAD_ZOOM);
      if (zoomOutActivo) distanciaCamara = Math.min(50, distanciaCamara + VELOCIDAD_ZOOM);
      
      // Actualizar cámara
      if (camaraArribaActiva) {
        anguloVertical -= VELOCIDAD_CAMARA;
        if (anguloVertical < -89) anguloVertical = -89;
      }
      if (camaraAbajoActiva) {
        anguloVertical += VELOCIDAD_CAMARA;
        if (anguloVertical > 89) anguloVertical = 89;
      }
      if (camaraIzquierdaActiva) anguloHorizontal += VELOCIDAD_CAMARA;
      if (camaraDerechaActiva) anguloHorizontal -= VELOCIDAD_CAMARA;

      // Normalizar ángulos
      if (rotacionObjetoX >= 360) rotacionObjetoX -= 360;
      if (rotacionObjetoY >= 360) rotacionObjetoY -= 360;
      if (rotacionObjetoZ >= 360) rotacionObjetoZ -= 360;

      // Actualizar la cámara
      actualizarCamara();

      // Matriz del Modelo
      identidad(MatrizModelo);
      traslacion(MatrizModelo, traslacionX, traslacionY, 0);
      escalacion(MatrizModelo, 5, 5, 5);
      rotacionX(MatrizModelo, rotacionObjetoX);
      rotacionY(MatrizModelo, rotacionObjetoY);
      rotacionZ(MatrizModelo, rotacionObjetoZ);
      multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      // Configurar textura si existe
      if (modeloGLB && modeloGLB.texturaGL) {
        gl.uniform1i(uTieneTextura, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, modeloGLB.texturaGL);
        gl.uniform1i(uTextura, 0);
      } else {
        gl.uniform1i(uTieneTextura, false);
      }

      modeloGLB.dibuja(gl);

      requestAnimationFrame(dibuja);
    }

    function reinicia() {
      identidad(MatrizRotacion);
      anguloVertical = 0;
      anguloHorizontal = 0;
      distanciaCamara = 10;
      rotacionObjetoX = 0;
      rotacionObjetoY = 0;
      rotacionObjetoZ = 0;
      rotarXActivo = false;
      rotarYActivo = false;
    }

    /***************************************************************************/
    /* Main                                                                    */
    /***************************************************************************/
    async function main() {
      canvas = document.getElementById("webglcanvas");
      gl = canvas.getContext("webgl2");
      if (!gl) {
         document.write("WebGL 2.0 no está disponible en tu navegador");
         return;
      }

      // Eventos del ratón
      canvas.addEventListener("mousedown", mouseDown, false);
      canvas.addEventListener("mouseup", mouseUp, false);
      canvas.addEventListener("mouseout", mouseUp, false);
      canvas.addEventListener("mousemove", mouseMove, false);
      canvas.addEventListener("wheel", mouseWheel, false);
      canvas.addEventListener("contextmenu", (e) => e.preventDefault(), false);

      // Eventos de los botones
      document.getElementById("reset").onclick = reinicia;
      document.getElementById("rotarArriba").onclick = animarCamaraArriba;
      document.getElementById("rotarAbajo").onclick = animarCamaraAbajo;
      document.getElementById("rotarIzquierda").onclick = animarCamaraIzquierda;
      document.getElementById("rotarDerecha").onclick = animarCamaraDerecha;
      document.getElementById("zoomIn").onclick = animarZoomIn;
      document.getElementById("zoomOut").onclick = animarZoomOut;
      document.getElementById("rotarZ").onclick = animarRotacionZ;
      
      // Eventos para rotación continua en X e Y (toggle con click)
      document.getElementById("rotarX").onclick = iniciaRotacionX;
      document.getElementById("rotarY").onclick = iniciaRotacionY;

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      compilaEnlazaLosShaders();

      arcBall = new ArcBall(canvas.width, canvas.height);

      gl.useProgram(programaID);
      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      uTextura = gl.getUniformLocation(programaID, "uTextura");
      uTieneTextura = gl.getUniformLocation(programaID, "uTieneTextura");
      
      perspective(MatrizProyeccion, 45, 1.0, 0.1, 100);
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      
      identidad(MatrizVista);
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      identidad(MatrizRotacion);

      arcBall.ajusta(gl.canvas.width, gl.canvas.height);

      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.53, 0.81, 0.92, 1.0);

      // Cargar el modelo GLB
      try {
        const loader = new GLTFLoader();
        const geometria = await loader.load('modelo/dragon.glb');
        modeloGLB = new ModeloGLB(gl, geometria);
        document.getElementById('loading').style.display = 'none';
        console.log('Modelo GLB cargado correctamente');
      } catch (error) {
        console.error('Error al cargar el modelo GLB:', error);
        document.getElementById('loading').innerHTML = 
          '❌ Error al cargar el modelo.<br>Verifica que el archivo GLB esté en la carpeta "modelo/"';
      }

      dibuja();
    }
    
    window.onload = main;
  </script>
</body>
</html>