<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Batalla Naval WebGL</title>
</head>
<body>
  <h2>Batalla Naval WebGL</h2>
  <canvas id="lienzo" width="500" height="500"></canvas>

  <!-- Vertex Shader -->
  <script id="vs" type="x-shader/x-vertex">
  #version 300 es
  layout(location=0) in vec2 posicionVertice;

  uniform mat4 matrizModelo;
  uniform mat4 matrizVista;
  uniform mat4 matrizProyeccion;

  void main() {
    gl_Position = matrizProyeccion * matrizVista * matrizModelo * vec4(posicionVertice, 0.0, 1.0);
  }
  </script>

  <!-- Fragment Shader -->
  <script id="fs" type="x-shader/x-fragment">
  #version 300 es
  precision mediump float;

  uniform vec4 colorUniforme;
  out vec4 fragColor;

  void main() {
    fragColor = colorUniforme;
  }
  </script>

  <script>
  const lienzo = document.getElementById("lienzo");
  const gl = lienzo.getContext("webgl2");
  // Sonidos
  const sonidoAgua = new Audio("agua.mp3");
  const sonidoImpacto = new Audio("impacto.mp3");


  // Configuración inicial
  gl.viewport(0, 0, lienzo.width, lienzo.height);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Funciones auxiliares
  function crearShader(tipo, fuente) {
    const shader = gl.createShader(tipo);
    gl.shaderSource(shader, fuente);
    gl.compileShader(shader);
    return shader;
  }

  function matrizIdentidad() {
    return new Float32Array([
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ]);
  }

  // Crear programa WebGL
  const shaderVertice = crearShader(gl.VERTEX_SHADER, document.getElementById("vs").text.trim());
  const shaderFragmento = crearShader(gl.FRAGMENT_SHADER, document.getElementById("fs").text.trim());

  const programa = gl.createProgram();
  gl.attachShader(programa, shaderVertice);
  gl.attachShader(programa, shaderFragmento);
  gl.linkProgram(programa);
  gl.useProgram(programa);

  // Uniforms y atributos
  const ubicacionMatrizModelo      = gl.getUniformLocation(programa, "matrizModelo");
  const ubicacionMatrizVista       = gl.getUniformLocation(programa, "matrizVista");
  const ubicacionMatrizProyeccion  = gl.getUniformLocation(programa, "matrizProyeccion");
  const ubicacionColor             = gl.getUniformLocation(programa, "colorUniforme");
  const posicion = 0;

  gl.uniformMatrix4fv(ubicacionMatrizProyeccion, false, matrizIdentidad());
  gl.uniformMatrix4fv(ubicacionMatrizVista, false, matrizIdentidad());

  // Tablero 10x10
  const tamañoTablero = 10;
  let tablero = Array.from({ length: tamañoTablero }, () => Array(tamañoTablero).fill(0));

  // Estados:
  // 0 = vacío
  // 1 = barco
  // 2 = agua disparada
  // 3 = barco impactado

  // Barco de 4 casillas
  tablero[0][0] = 1;
  tablero[0][1] = 1;
  tablero[0][2] = 1;
  tablero[0][3] = 1;

  // Barcos de 3 casillas
  tablero[2][5] = 1;
  tablero[3][5] = 1;
  tablero[4][5] = 1;

  tablero[6][0] = 1;
  tablero[6][1] = 1;
  tablero[6][2] = 1;

  // Barcos de 2 casillas
  tablero[1][7] = 1;
  tablero[2][7] = 1;

  tablero[5][8] = 1;
  tablero[6][8] = 1;

  tablero[8][3] = 1;
  tablero[8][4] = 1;

  // Barcos de 1 casilla
  tablero[9][0] = 1;
  tablero[9][9] = 1;
  tablero[4][2] = 1;
  tablero[7][7] = 1;

  // Dibuja un cuadro
  function dibujarCuadro(x, y, tamaño, color) {
    const mitad = tamaño / 2;
    const vertices = [
      x - mitad, y - mitad,
      x + mitad, y - mitad,
      x + mitad, y + mitad,
      x - mitad, y + mitad
    ];

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(posicion);
    gl.vertexAttribPointer(posicion, 2, gl.FLOAT, false, 0, 0);

    gl.uniformMatrix4fv(ubicacionMatrizModelo, false, matrizIdentidad());
    gl.uniform4f(ubicacionColor, color[0], color[1], color[2], 1);
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
  }

  // Renderizar todo el tablero
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    const tamañoCelda = 2 / tamañoTablero;

    for (let fila = 0; fila < tamañoTablero; fila++) {
      for (let col = 0; col < tamañoTablero; col++) {
        let cx = -1 + tamañoCelda / 2 + col * tamañoCelda;
        let cy =  1 - tamañoCelda / 2 - fila * tamañoCelda;

        let estado = tablero[fila][col];
        let color = [0.3, 0.7, 0.9]; // azul por defecto

        if (estado === 2) color = [0.1, 0.5, 0.8]; // agua disparada
        if (estado === 3) color = [1, 0, 0];       // barco impactado
        if (estado === 1) color = [0.3, 0.8, 0.3]; // barco verde

        dibujarCuadro(cx, cy, tamañoCelda * 0.9, color);
      }
    }
  }

  render();

  // Manejo de clics
  lienzo.addEventListener("click", e => {
    // Obtener posición del clic relativa al canvas
    const rect = lienzo.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / lienzo.width) * 2 - 1;
    const y = -(((e.clientY - rect.top) / lienzo.height) * 2 - 1);

    // Convertir a fila y columna del tablero 10x10
    const col = Math.floor((x + 1) / 2 * tamañoTablero);
    const fila = Math.floor((y + 1) / 2 * tamañoTablero);

    // Verificar que esté dentro del tablero
    if (fila >= 0 && fila < tamañoTablero && col >= 0 && col < tamañoTablero) {
        // Actualizar estado del tablero y reproducir sonido
        if (tablero[fila][col] === 0) {
            tablero[fila][col] = 2; // agua disparada
            sonidoAgua.currentTime = 0; // reiniciar sonido
            sonidoAgua.play();
        } else if (tablero[fila][col] === 1) {
            tablero[fila][col] = 3; // barco impactado
            sonidoImpacto.currentTime = 0; // reiniciar sonido
            sonidoImpacto.play();
        }

        // Volver a dibujar tablero
        render();
    }
  });

  </script>
</body>
</html>
